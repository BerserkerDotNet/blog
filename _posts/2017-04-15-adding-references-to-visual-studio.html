---
layout: post
title: Adding references to Visual Studio extension project
date: '2017-04-15T20:35:00.001-07:00'
author: Andrii Snihyr
tags:
- Visual Studio extension
- FileNotFoundException
- Visual Studio
- references
- assembly
- WPF
- ProvideBindingPath
modified_time: '2017-04-15T20:35:52.560-07:00'
thumbnail: https://1.bp.blogspot.com/-C2-G0YSSQ2g/WPGF3lIIRiI/AAAAAAAAAF8/yZ6J9rYi9xggfTE3VK39i7Sql0pW0uRgACLcB/s72-c/FileNotFoundException.png
---
 
 This might sound like a very simple thing to do, just right click -&gt; "Add References" -&gt; Select an assembly and done.
Even easier, just add a NuGet package.<br />Well, not quite. When I added a NuGet package to one of my extension projects
I got a runtime error that took me some time to figure out. So I though it might be a good idea to write about it.<br />
<!--more-->
<div><br /></div>
<div>The package I added was&nbsp;<a href="https://www.nuget.org/packages/Extended.Wpf.Toolkit/">Extended WPF Toolkit</a>, I like
    the controls they have. With a package in place I added a WatermarkTextBox control to my XAML like this:</div>
<div></div>
<pre class="prettyprint">&lt;UserControl x:Class="Ext1.ToolWindow1Control"<br />             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"<br />             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"<br />             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"<br />             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"<br />             xmlns:xctk="http://schemas.xceed.com/wpf/xaml/toolkit"<br />             mc:Ignorable="d"&gt;<br />    &lt;Grid&gt;<br />        &lt;StackPanel Orientation="Vertical"&gt;<br />            &lt;xctk:WatermarkTextBox Watermark="Enter your name..." Text="{Binding UserName}"/&gt;<br />            &lt;Button Content="Submit" Command="{Binding DoSubmit}"/&gt;<br />        &lt;/StackPanel&gt;<br />    &lt;/Grid&gt;<br />&lt;/UserControl&gt;<br /></pre>
<div>When I ran the app, I got an exception:<br />
    <div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-C2-G0YSSQ2g/WPGF3lIIRiI/AAAAAAAAAF8/yZ6J9rYi9xggfTE3VK39i7Sql0pW0uRgACLcB/s1600/FileNotFoundException.png"
            imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="152" src="https://1.bp.blogspot.com/-C2-G0YSSQ2g/WPGF3lIIRiI/AAAAAAAAAF8/yZ6J9rYi9xggfTE3VK39i7Sql0pW0uRgACLcB/s400/FileNotFoundException.png" width="400" /></a></div>
    <div
        class="separator" style="clear: both; text-align: center;"><br /></div>
</div>
<div>What?! FileNotFound exception! Okay, lets take a look maybe our newly added assembly is not being copied to the output folder.
    No it is there:<br />
    <div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-DPjoEFwxH1k/WPGHRApzUQI/AAAAAAAAAGI/Zz-sLQEWp6oIcZwgnM2TFaNl6nxGMztuwCLcB/s1600/DLLInOutputFolder.png"
            imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="191" src="https://1.bp.blogspot.com/-DPjoEFwxH1k/WPGHRApzUQI/AAAAAAAAAGI/Zz-sLQEWp6oIcZwgnM2TFaNl6nxGMztuwCLcB/s400/DLLInOutputFolder.png" width="400" /></a></div><br
    /></div>
<div>By examining an exception details more carefully I found that when I open my extension (toolwindow in this case), Visual
    Studio attempts to load a toolkit assembly, but the problem is that it is a Visual Studio loading this assembly not my
    extension and so the AppBase path is a path to a Visual Studio folder.<br />Here are Fusion logs from the exception:<br
    /><i><span style="color: #cc0000;">LOG: Appbase = file:///C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/Common7/IDE/</span></i><br
    /><i>LOG: Attempting download of new URL .../Community/Common7/IDE/Xceed.Wpf.Toolkit.DLL.</i><br /><i>LOG: Attempting download of new URL&nbsp;</i><i>.../</i><i>Community/Common7/IDE/Xceed.Wpf.Toolkit/Xceed.Wpf.Toolkit.DLL.</i><br
    /><i>LOG: Attempting download of new URL&nbsp;</i><i>.../</i><i>Community/Common7/IDE/PublicAssemblies/Xceed.Wpf.Toolkit.DLL.</i><br
    /><i>LOG: Attempting download of new URL&nbsp;</i><i>.../</i><i>Community/Common7/IDE/PublicAssemblies/Xceed.Wpf.Toolkit/Xceed.Wpf.Toolkit.DLL.</i><br
    /><i><br /></i>They clearly indicate that Visual Studio is not looking at the correct place. Now when it is clear why
    Visual Studio can't find the assembly, lets take a look on how it can be fixed.<br /><br /><b>Approach #1.</b> Force
    the assembly to be a reference in the extension assembly itself.<br />Since <i>Xceed.Wpf.Toolkit.dll </i>is only used
    from XAML markup, extension assembly will not have a reference to it.<br />
    <div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-lz_fZIUELGs/WPKpaYK5ZXI/AAAAAAAAAGY/PEeg00DKFF0D9IVqZrnRqx9pccgP6EU7gCLcB/s1600/no_reference.png"
            imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="192" src="https://4.bp.blogspot.com/-lz_fZIUELGs/WPKpaYK5ZXI/AAAAAAAAAGY/PEeg00DKFF0D9IVqZrnRqx9pccgP6EU7gCLcB/s400/no_reference.png" width="400" /></a></div>To
    force it to be a reference, types from this assembly have to be used from C#.<br />Something as simple as: typeof(WatermarkTextBox)
    will do.<br /><br />
    <pre class="prettyprint">[MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]<br />private void MakeARefrenceToNecessaryTypes()<br />{<br />    var type = typeof(WatermarkTextBox);<br />}<br /></pre><br />This code ideally needs to be somewhere in the package initialization, to guaranty it is executed before any XAML
    components are loaded. The way it works now is that when extension assembly is loaded all its references are loaded as
    well. The benefit is that only the assemblies that are really required by my extension are loaded and nothing more.<br
    />There are few downsides to this approach. I need to add to the list when I'm adding new stuff. Also compiler optimizations
    can take away things that are not really used in my code. That is why I decorated it with MethodImpl attribute.<br /><br
    /><b>Approach #2.</b> Set&nbsp;<a href="https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.modeling.shell.providebindingpathattribute.aspx">ProvideBindingPath </a>attribute
    on a package class.<br />This attribute will add a directory where the package is installed to the Visual Studio probing
    list.<br />So when VS will attempt to load toolkit assembly it will find it.<br />This looks like much cleaner solution
    on the surface, but there are consequences. By adding the entire folder of my extension to the probing list, I'm exposing
    every assembly that is there, and so it might hit a performance if there are too many assemblies or even accidentally
    break another extension as it might get a version of the assembly from my package. In theory everything that is in that
    folder is used by the extension anyway, so the scenario of crashing some other extension is remote. But still it is good
    to be aware of the possibility.<br />Also, there is a way to specify a SubPath with this attribute though, that limits
    the exposure.<br /><br /><b>Approach #3.</b> Subscribe to AppDomain.AssemblyResolve event and resolve it manually.<br
    />This is somewhat similar to the previous approach, but requires a bit more code.<br />Here is an example:<br />
    <pre
        class="prettyprint">protected override void Initialize()<br />{<br /> AppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve;<br
        /> ToolWindow1Command.Initialize(this);<br /> base.Initialize();<br />}<br /><br />private Assembly CurrentDomain_AssemblyResolve(object
        sender, ResolveEventArgs args)<br />{<br /> try<br /> {<br /> AssemblyName name = new AssemblyName(args.Name);<br
        /> return AppDomain.CurrentDomain.Load(name);<br /> }<br /> catch<br /> {<br /><br /> return null;<br /> }<br />}<br
        /><br />protected override void Dispose(bool disposing)<br />{<br /> AppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve;<br
        /> base.Dispose(disposing);<br />}<br /></pre><br />In this case when assembly resolution fails, the event will fire
        and allow me to resolve the assembly manually. The difference is that now it executes in the context of my extension
        and so the base path is set to the root of the extension. In the above implementation it still have a problem of
        exposing all of the assemblies that are in the root of an extension, but you can fine grain the list and allow only
        the assemblies you need.<br /><br />In my case I decided to choose an approach #2, It is the simplest and the cleanest
        approach with no maintenance required.<br /><br />Another thing I want to mention regarding references in the Visual
        Studio extension projects is that any assembly you want to directly reference in your extension project must be signed.<br
        />The reason is simple, extension assembly is &nbsp;signed and since it is signed it cannot reference an unsigned
        assemblies. You will get a following error if you'll attempt to reference an unsigned assembly:<br /><i>Could not load file or assembly 'MVVM.Essentials.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' or one of its dependencies. A strongly-named assembly is required.</i>
        <span
            class="Apple-tab-span" style="white-space: pre;"> </span><br />
            <div><br /></div>
            <div>Happy coding :)</div><br /></div>